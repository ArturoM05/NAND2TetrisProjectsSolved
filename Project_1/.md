# Nand2tetris Project 1 Solved

## Explanation of the topic 
Before you read the solution of this project it's important have an idea of what are we doing and why are we doing it, so I recommend read [Lecture 1](https://drive.google.com/file/d/1MY1buFHo_Wx5DPrKhCNSA2cm5ltwFJzM/view).

In case You don't want to read it, this is an small summary:

### Basic Concepts

Boolean Values: Basically They're values that can only have two possible states, for examples: true/false, on/off, yes/no and 1/0

if we have one boolean variable we have 2 posible states but if we add more variables the posible states increases following this pattern 2^n where n is the number of boolean variables, for example 
if we have 4 variables, we woud have 2^4 (16) posible states.

Bolean functions: Similar to an usual math function, given a number of boolean values we return a boolean value.

Truth Table: This is a tool to represent how an boolean function/expression works, for example:
This is the truth table of the function AND that if we see as true and false, only return true when both variables are true 
| a | b | out |  
|-- | --|:---:|
| 0 | 0 |  0  |
| 0 | 1 |  0  |
| 1 | 0 |  0  |
| 1 | 1 |  1  |
 
>  the order of the values is given by the numeric in the binary system, that is, in this case we count from 0 to 3 in binary. Watch this video if you are curious about [
How to Count in Binary](https://www.youtube.com/watch?v=HF2OeNpvakw).
<img width="600" alt="Truth table" src="https://github.com/user-attachments/assets/278b8d4e-2c9f-4e56-b520-a65f5f38e9d2" />

### The power of Nand 
Nand is a boolean function that return the same of AND but denied
that mean if we deny the output of a Nand function we get an usual AND function, the same way using logic and boolean algebra we can realize every elementary bolean function (NOT, AND, OR).

We can build any function with the basic ones so if we can build any elementary function with a NAND. Basically we can build any function only with nand functions.

### Logic gates
As we said at the beginning, all values that can have two states can be represented as Boolean values. This also applies to electronics where we have two possible states 0 (low voltage 0-1v ) and 1 (high voltage 5v) therefore we can build the so-called logic gates that allow us to perform the Boolean functions seen before.

<img width="600" alt="Logic gates" src="https://github.com/user-attachments/assets/c0438df9-5c67-4f0f-8a24-bb5a9cd202f3" />


### Building a CHIP: Hardware description languages (HDL)
To build CHIPs we are going to use a programming language with a syntax similar to the one in Java called HDL and we will use the [Nand2Tetris Online IDE](https://nand2tetris.github.io/web-ide/chip) to simulate CHIPS.

for each CHIP we have its visual representation for example the CHIP XOR with the following visual representation and truth table:

<img width="600" alt="XOR" src="https://github.com/user-attachments/assets/99fb5a06-f41c-4399-9bb6-8b43aca3b25d" />

To represent it in HDL We need build it with elementary gates (NOT, AND, OR).
> it is a good idea to do the exercise of going from the truth table to elementary gates by yourself to remember useful things such as simplification by logical/mathematical rules, karnaugh maps, minterms and maxterms that will be useful in carrying out some parts of the project.

Well, using minterms I get the follow function XOR = (A*Not(B))+(Not(A)*(B)). Now we have the function in terms of elementary gates we can descript it in HDL 
every CHIP in HDL has two section:
- Interface: where we determine the name of the CHIP, how many inputs they're going to have and be called and the same with the output.
``` HDL
   CHIP NAME_GATE {
     IN NAME_IN, NAME_IN1;
     OUT NAME_OUT;

    // ...
       Implementation
    // ...
   }   
```
> we can call as we want the inputs, the outputs and even the CHIP

- Implementation: where we set which gates are going to build our CHIP and how this gates are going to be used.
```HDL
   // ...
   PARTS:
     NAME_GATE(in=NAME_IN, out=NAME_OUT); // case with one input
     NAME_GATE(a=NAME_IN, b=NAME_IN1, out=NAME_OUT); // case with two inputs
   // ...
```
So our CHIP XOR looks like:
```
 CHIP Xor {
  IN a, b;
  OUT out;
 PARTS:
  Not (in=a, out=nota);
  Not (in=b, out=notb);
  And (a=a, b=notb, out=aAndNotb);
  And (a=nota, b=b, out=notaAndb);
  Or (a=aAndNotb, b=notaAndb, out=out);
 }
```
Things to keep in mind, the outs of each gate can be called whatever you want except the one that gives us the final out since this determines the output of the CHIP so it must be called the same as what we call them in the interface in this case "out". It is very important to maintain coherence between the outputs and inputs between each gate, so I recommend drawing the CHIP diagram and following it to avoid errors.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c4edbeaf-4a4b-4ba5-9571-13bc0a9b9b2c" />

### Let's get to know the Nand2Tetris IDE
<img width="1869" height="920" alt="image" src="https://github.com/user-attachments/assets/766f601c-1d00-444a-8a6a-bc9d70302ca3" />
For this project we are going to focus only in the marked areas:

Orange: Change the implementation of the current CHIP for one already built, helping us test and understand how the CHIPs should behave.

Pink: Here we can choose which project we will work

Purple: In this case we have multiple CHIPs to implement, so here we can choose which CHIP we will implement

Red: Here is where we put our code

Green: Here is where we test the CHIP. Recommendation play with these buttons.

Yellow: After test the CHIP, Here we will see a message specifying whether the CHIP is built correctly or incorrectly

With This Information I think you are ready to start solving Project 1.








